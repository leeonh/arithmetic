package day06

/*
岛屿数量

给你一个由'1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。



示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
示例 2：

输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

*/

// 创建移动策略 x,y对应上 右 下 左
var (
	//x轴
	dx = []int{0, 1, 0, -1}
	//y轴
	dy = []int{1, 0, -1, 0}
)

/*
广度优先 BFS
*/
func numIslands(grid [][]byte) int {
	// 定义岛屿数量
	ans := 0
	// 循环岛屿每个点，如果为'1'，就BFS广度优先，将相邻的'1'，全部标记为已访问'2'，然后岛屿数量+1
	n, m := len(grid), len(grid[0])
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			// 如果为'1'，则广度搜索，将相邻的'1'，全部标记为已访问'2'
			if grid[i][j] == '1' {
				// 创建队列，存放要搜索的坐标
				queue := make([][]int, 0)
				queue = append(queue, []int{i, j})
				// 广度搜索，队列不为空，就一直循环队列
				for len(queue) > 0 {
					// 弹出队列的坐标
					cur := queue[0]
					// 模拟队列弹出
					queue = queue[1:]
					// 四个方向扫描，如果没越界，遇到'1'的坐标，就加入队列
					for k := 0; k < 4; k++ {
						// x轴移动
						x := cur[0] + dx[k]
						// y轴移动
						y := cur[1] + dy[k]
						// 坐标移动后，不能超界，如果不等于'1'直接跳过
						if x < 0 || x >= n || y < 0 || y >= m || grid[x][y] != '1' {
							continue
						}
						// 如果等于'1'，坐标加入队列
						queue = append(queue, []int{x, y})
						grid[x][y] = '2'
					}

				}
				// 等上面的广度搜索将相邻的'1'都修改为'2'后，岛屿+1
				ans++
			}
		}
	}
	return ans
}
