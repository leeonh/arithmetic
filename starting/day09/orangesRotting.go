package day09

/**
在给定的m x n网格grid中，每个单元格可以有以下三个值之一：

值0代表空单元格；
值1代表新鲜橘子；
值2代表腐烂的橘子。
每分钟，腐烂的橘子周围4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回-1。
*/

func OrangesRotting(grid [][]int) int {
	// 全部橘子腐蚀完毕的时间
	minutes := 0
	// 全部橘子的数量
	count := 0
	m, n := len(grid), len(grid[0])
	// 队列，用来放腐烂的橘子坐标
	queue := [][]int{}

	// 先找到已经腐烂了的橘子
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] > 0 {
				// 大于0就是橘子，不管是否腐烂，都算一个橘子
				if grid[i][j] == 1 {
					count++
				}
				if grid[i][j] == 2 {
					queue = append(queue, []int{i, j})
				}
			}

		}
	}
	// 循环模拟队列弹出，如果队列不为空，就循环弹出(切片),如果好橘子已经全部烂掉了，就提前退出循环
	for count > 0 && len(queue) > 0 {
		// 提前存一份队列长度，因为腐烂扩散是并发的，多个腐烂的橘子，会同时向四周腐蚀，所以提前存的腐烂橘子的队列长度，循环这个队列，就相当于同一分钟内，多个腐烂的橘子同时向四周腐烂
		size := len(queue)
		for a := 0; a < size; a++ {
			// 将队列里面的坐标拿出来
			cell := queue[0]
			queue = queue[1:]
			i, j := cell[0], cell[1]
			// 循环移动策略，分别移动上 下 左 右
			for d := 0; d < 4; d++ {
				// x轴移动后的坐标位置，因为0距离最近的0就是0，所以可以作为初始的距离，开始累加起来，每次
				x := i + move[d][0]
				// y轴移动后的坐标位置
				y := j + move[d][1]
				// 判断移动后是否超界，是否是新鲜的，如果是，则将其修改为腐烂，同时标识当前循环腐蚀扩散成功
				if x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1 {
					// 将橘子修改为腐烂
					grid[x][y] = 2
					// 新鲜橘子的数量减一
					count--
					// 将最新腐烂的橘子坐标，加入队列
					queue = append(queue, []int{x, y})

				}
			}

		}
		// 广度向外腐烂一轮后，分钟都加一
		minutes++

	}
	// 检查是否所有的橘子都已经腐烂了
	if count > 0 {
		return -1
	}
	return minutes
}
