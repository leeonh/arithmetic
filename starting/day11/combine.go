package day11

/**
 * 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
 */
func combine(n int, k int) [][]int {
	// 存储结果的二维数组
	var result [][]int
	if n < k || n <= 0 || k <= 0 {
		return result
	}
	// 存储单一结果的一维数组
	var path []int
	// result 和 path要定义再方法里面，定义在外面是全局变量，leetcode提交算法的时候，验算的时候result会重复使用，会把前一次的结果一起返回，所以得写成局部变量
	var getCombine func(int)
	// 递归得到结果
	getCombine = func(start int) {
		// 递归终止条件，当path一维数组的长度满足k的时候，将path加入result，并返回result
		if len(path) == k {
			temp := make([]int, k)
			copy(temp, path)
			result = append(result, temp)
			return
		}
		// 循环递归，将后面的数字放进path里面进行组合,循环从1开始
		/*
			优化，因为每次递归后,start也就是开始的数字，都会往后加1，例如1，2，3，4，5， 如果k=3，那么其实当start从4开始，无论怎么递归，

			4和5都不可能组合出不重复的3个数字了，所以没有必要继续递归搜索下去了，那么我们可以直接推出这个起始位置start至多要从哪个地方开始

			就像上面的1，2，3，4，5，k=3，起始位置至多只能从3开始，因为从4开始就无法组合出3个数字了，那么：

			根据递归存储的结果，path.size()拿到已经存储了的数字

			算出我们还差几个数字就能满足k : k - path.size()

			推出在集合n中至多起始位置 : n - (k - path.size()) + 1，为什么加1，参考下面的例子

			用上面的例子验算一下，1，2，3，4，5， n=5，k=3，path.size() = 0，start来到了1，5 - (3 - 0) + 1 = 3

			我们举例子就知道，start最多只能从3开始，但是如果不+1，算出来的数是2，因为start是从1开始的，要把1这个数字的位置也包含进来

			也就是从3开始递归搜索存储组合，都是合理的，例如[3,4,5]
		*/

		for i := start; i <= n-(k-len(path))+1; i++ {
			// 将数字存入path
			path = append(path, i)
			/*
				递归循环存入所有后续的数字组合，根据 n - (k - path.size()) + 1

				例如start从1开始，循环到3, [1,2,3] 相当于有3种分支情况

				如果是1这条分支，那再递归后，start就变成了2开始循环到4，[2,3,4] 有3种分支情况

				如果是2这条分支，再次递归，start变成3，循环到5 [3,4,5] 有3种分支情况

				当前一条分支最终组成的数组有3个，[1,2,3],[1,2,4],[1,2,5]

				以此类推，如果最上层是选择了2这条分支，组合的数组是，[2,3,4],[2,3,5],[2,4,5]

				以此类推，如果最上层是选择了3这条分支，组合的数组是，[3,4,5]
			*/
			getCombine(i + 1)
			// 每一层递归完后，进行回溯，也就是恢复到上一层的状态，例如当前递归已经循环到，[1,2]，现在进行第三个数的获取
			//然后选择了3，那么path[1,2,3]的长度就满足了k，丢进去result里面，然后递归就会返回到上一层又回到了[1,2]，相当于把3撤回了，再次从[1,2]继续选择后面的4，5进行组合
			path = path[:len(path)-1]
		}
	}
	getCombine(1)
	return result
}
