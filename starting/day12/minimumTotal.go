package day12

/**
给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。


示例 1：

输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为11（即，2+3+5+1= 11）。
示例 2：

输入：triangle = [[-10]]
输出：-10
*/
func minimumTotal(triangle [][]int) int {
	n := len(triangle)
	// 用一个一维数组存储最低最小路径和，比n还要多一位的原因就是，防止下面的j+1越界的问题，有了这个，就不用if判断越界了
	dp := make([]int, n+1)
	// 从下至上的逆推回去，每一层都去下一层找出j和j+1中最小的数字，来和自己相加替换掉自己
	// 例如上面的最底层是4 1 8 3，因为是最底层了，没有下一层了，所以dp里面存储的都是它们自己，也就是 triangle[3][0] 到 triangle[3][3]，结果为：dp[0]=4 dp[1]=1 dp[2]=8 dp[3]=3
	// 循环再往上走一层是6 5 7，dp[0] = min(dp[0],dp[1]) + triangle[2][0]，dp[0]=4 dp[1]=1，取最小值就是1+triangle[2][0]=7，那dp[0]就会替换成7来作为上一层的判断条件了，以此类推
	for i := n - 1; i >= 0; i-- {
		for j := 0; j < len(triangle[i]); j++ {
			dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]
		}
	}

	return dp[0]
}
func min(a, b int) int {
	if a < b {
		return a

	} else {
		return b
	}
}
